COMMENT *

Лабораторная № 2 
Выполнить задание 1 (вариант 12), изменив условие следующим образом
- Размер массива ввести с клавиатуры                                                   
- Массив ввести с клавиатуры
- Введенный массив вывести на экран
- Обработку массива оформить в виде процедуры
- Массив и другие входные данные (если они есть) передать параметрами через стек

Вариант 12
Имеют ли все числа одинаковый знак  

Данильченко Роман, 9 гр.

*  
  
ORG 100H

.CODE

start: 
    ; Вывод строки с просьбой ввести размер массива
    MOV     AH, 09H
    LEA     DX, enterArrSizeMessage
    INT     21H      
                     
    ; Считывание фактического размера массива в AX и инициализация соответствующей переменной                     
    CALL    ReadInteger    
    MOV     arrSize, AX
         
    ; Перевод строки
    CALL    NewLine  
                
    ; Присваивание DI адреса массива для дальнейшего считывания в массив чисел, присваивание BX как счётчику введенных чисел значения 0            
    LEA     DI, arrWithNumbers
    MOV     BX, 0

readArray:      
    ; Вывод строки с просьбой ввести очередное число
    MOV     AH, 09H
    LEA     DX, enterNumberMessage
    INT     21H        
    
    ; Считывание очередного числа в AX 
    CALL    ReadInteger  
    
    ; Добавление очередного числа в массив и увеличение адреса для следующего числа на 2 байта
    MOV     [DI], AX
    ADD     DI, 2
        
    ; Перевод строки    
    CALL    NewLine      
        
    ; Увеличение счётчика введенных чисел и сравнение его с фактическим количеством чисел, которое нужно ввести   
    INC     BX
    CMP     BX, arrSize
    JB      readArray       ; Если ввели меньше чисел, чем было заявлено, считываем следующее число
                   
    ; Вывод строки перед выводом содержимого массива                
    MOV     AH, 09H
    LEA     DX, enteredArrMessage
    INT     21H
    
    ; Обнуление BX, теперь он будет служить индексом выводимого в консоль числа в массиве
    MOV     BX, 0
    MOV     CX, arrSize     ; Записываем фактический размер массива в CX для прохода по нему в цикле
    
printArray:
    ; Вывод очередного числа из массива       
    MOV     AX, arrWithNumbers[BX]
    CALL    WriteInteger
    ADD     BX, 2  
    
    ; Вывод пробела между числами           
    CALL    WriteSpace             
                 
    ; Пока не выведем все числа в массиве <=> пока CX не станет равно 0
    LOOP    printArray
    
    ; Перевод строки
    CALL    NewLine
    
    ; Передача адреса массива и его фактического размера в основную процедуру через стек        
    LEA     BX, arrWithNumbers
    PUSH    BX        
    PUSH    arrSize
                 
    ; Вызов основной процедуры             
    CALL    AreAllNumbersHaveSameSign   
    
    ; Выход из программы
    MOV     AX, 4C00H	
    INT     21H
    

AreAllNumbersHaveSameSign PROC 
    ; Cохраняем содержимое регистров BP, AX, CX, SI и DI, которые используются в этой процедуре, в стек
    PUSH    BP
    MOV     BP, SP  ; Копируем адрес последнего добавленного в стек элемента (BP) в BP
    PUSH    AX
    PUSH    CX
    PUSH    SI
    PUSH    DI
    
;  Содержимое стека:
                                           
;  |       DI       |                
;  |       SI       |                
;  |       CX       |                 
;  |       AX       |                
;  |       BP       | <-- BP        
;  |       IP       |                                                                    
;  |     arrSize    | <-- BP + 4     
;  | arrWithNumbers | <-- BP + 6     
;  |................|               
   
; Верхние 5 элементов стека (до BP включительно) были добавлены в этой процедуре,
; IP (адрес возврата из процедуры) был добавлен при вызове этой процедуры,
; arrSize и arrWithNumbers были добавлены в предыдущей процедуре 
    
    ; Достаём из стека фактический размер и адрес массива
    MOV     CX, [BP + 4]    ; CX - Фактический размер                                                         
    MOV     SI, [BP + 6]    ; SI - Адрес массива
    
    ; Сразу уменьшим кол-во чисел для обработки, потому что будем сравнивать соседние числа 
    DEC     CX
               
compareSignsOfNearElements:   
    ; Достаем из массива очередное число и сравниваем его знак со знаком следующего
    MOV     AX, [SI]
    XOR     AX, [SI + 2]   
    JS      foundDifferentSigns     ; Если нашли числа с различными знаками выходим из цикла
    ADD     SI, 2                   ; Иначе увеличиваем "индекс" на 2 байта
    
    ; Пока не обработаем все соседние пары чисел
    LOOP    compareSignsOfNearElements
    
    ; Если вышли из цикла, значит все числа в массиве имели один знак
    MOV     DX, OFFSET trueMessage
    JMP     printAnswer  
    
foundDifferentSigns:        
    MOV     DX, OFFSET falseMessage
       
printAnswer:
    ; Вывод результата
    MOV     AH, 09H			
    INT     21H							    							   
    
    ; Восстановление значений в регистрах DI, SI, CX, AX и BP, которые были в них до основной процедуры        
    POP     DI
    POP     SI
    POP     CX
    POP     AX
    POP     BP      
                            
    RET     
AreAllNumbersHaveSameSign ENDP             
                
                
; Процедура ввода десятичного целого числа, после процедуры введенное число будет записано в регистр AX     
ReadInteger PROC                
    ; Cохраняем содержимое регистров BX, CX и DX, которые используются в этой процедуре, в стек
    PUSH    BX
    PUSH    CX                          
    PUSH    DX
         
    XOR     CX, CX                  ; Обнуляем значение в регистре CX 
    MOV     BX, 10                  ; Помещаем 10 в регистр BX для схемы Горнера 
    CALL    ReadChar                ; Вызываем процедуру считывания символа, 
                                    ;       после процедуры считанный символ будет в регистре AL
    
    CMP     AL, '-'                 ; Сравниваем введенный символ с минусом
    JE      minusWasRead            ; Если введенным символом оказался минус, 
                                    ;       изменяем значение переменной, указывающей на отрицательность вводимого числа
    
    MOV     isNegative, 0           ; Устанавливаем переменной, 
                                    ;       указывающей на отрицательность вводимого числа, значение 0 (false)  
    JMP     handleNumberSymbol      ; Первой была введена цифра, переходим к её обработке
                        
minusWasRead:
    MOV     isNegative, 1   ; Устанавливаем переменной, 
                            ;       указывающей на отрицательность вводимого числа, значение 1 (true)  

readAnotherChar: 
    CALL    ReadChar    ; Вызываем процедуру считывания символа, 
                        ;       после процедуры считанный символ будет в регистре AL
    
handleNumberSymbol: 
    CMP     AL, 13                  ; Сравниваем введённый символ с Enter'ом
    JE      wholeNumberWasRead      ; Если введенным символом оказался Enter, переходим к завершению считывания числа
    
    SUB     AL, '0'                 ; Иначе конвертируем считанный символ в цифру, вычисляя разность между ним и символом '0', и записывая её в регистр AL
                                   
    ; Обнуляем значения AH и DX                                   
    XOR     AH, AH                 
    XOR     DX, DX                 
                                      
; Сейчас в AX находится последняя считанная цифра,  
;       а в CX число, считанное до этого момента, которое нужно умножить на 10 (BX) и прибавить к результату последнюю считанную цифру

; Другими словами, CX = CX * 10 + AX <=> CX = CX * BX + AX                                    
                                               
    XCHG    CX, AX                  ; Меняем местами значения регистров CX и AX, чтобы умножить прежде считанное число на 10
    MUL     BX                      ; Умножаем прежде считанное число, сейчас находящееся в регистре AX, на 10
    ADD     AX, CX                  ; Добавляем к умноженному на 10 числу считанную цифру, 
    XCHG    AX, CX                  ;       получаем считанное до следующей цифры число, которое мы снова помещаем в регистр CX
    
    JMP     readAnotherChar         ; Переходим к считыванию очередного символа
    
wholeNumberWasRead:  
    XCHG    AX, CX                          ; Меняем местами значения регистров CX и AX, тем самым помещая считанное число в регистр AX  
    CMP     isNegative, 1                   ; Проверяем переменную, указывающую на отрицательность введенного числа
    JE      makeUnsignedNumberNegative      ; Если введенное число было отрицательным, переходим к изменению его знака
    JMP     reinitializeUsedRegisters       ; Иначе сразу переходим к восстановлению данных в регистрах
    
makeUnsignedNumberNegative:
    NEG     AX      ; Изменяем знак числа в регистре AX               
    
reinitializeUsedRegisters: 
    ; Восстановление значений в регистрах BX, CX и DX, которые были в них до считывания числа
    POP     DX      
    POP     CX  
    POP     BX 
    
    RET             ; Возвращаемся из процедуры
ReadInteger ENDP     
                     
                     
; Процедура ввода символа, после процедуры введенный символ будет записан в регистр AL 
ReadChar PROC  
    MOV     AH, 01H     ; Помещаем номер системной функции DOS 01H (ввод с клавиатуры) в AH  
    INT     21H         ; Вызываем функцию
    
    RET                 ; Возвращаемся из процедуры
ReadChar ENDP
           

; Процедура вывода десятичного числа, записанного в AX
WriteInteger PROC 
    ; Cохраняем содержимое регистров AX, BX, CX и DX, которые используются в этой процедуре, в стек  
    PUSH    AX                                          
    PUSH    BX  
    PUSH    CX  
    PUSH    DX  
    
    XOR     CX, CX                                      ; Обнуляем значение CX
    MOV     BX, 10                                      ; Помещаем число 10 в BX для целочисленного деления 
        
    TEST    AX, AX                                      ; Узнаем, отрицательное ли число, используя побитовое И   
    JS      printMinusAndMakeUnsigned                   ; Если отрицательное - выводим перед ним минус и меняем знак числа
    JMP     pushDigitsOfNumberToStackAndGetItsOrder     ; Иначе сразу переходим к получению цифр числа в стеке и его порядка

printMinusAndMakeUnsigned:
    PUSH    AX          ; Cохраняем содержимое регистра AX 
    
    MOV     DL, '-'     ; Помещаем минус в регистр DL 
    MOV     AH, 02H     ; Помещаем номер системной функции DOS 02H (вывод символа на дисплей) в регистр AH 
    INT     21h         ; Вызываем функцию
    
    POP     AX          ; Восстановление значения в регистре AX, которое было в нем до вывода минуса
    NEG     AX          ; Убираем минус у числа

; Получаем десятичные цифры, из которых состоит число (которое сейчас записано в AX), и добавляем их в стек
; В CX будет записан порядок числа (для 0..9 порядок 1, 10..99 2, ...)
pushDigitsOfNumberToStackAndGetItsOrder:  
    XOR     DX, DX                                      ; Обнуляем значение в регистре DX   
    IDIV    BX                                          ; Целочисленно делим число в AX на 10 (в BX). 
                                                        ;       Целая часть будет записана в AX,
                                                        ;       Остаток, который нам нужно добавить в стек, будет записан в DX
                              
    PUSH    DX                                          ; Добавляем очередную цифру числа в стек
    INC     CX                                          ; Увеличиваем порядок числа на единицу
    CMP     AX, 0                                       ; Узнаем, есть ли ещё в числе цифры, не добавленные в стек, путем сравнения его с нулем
    JG      pushDigitsOfNumberToStackAndGetItsOrder     ; Если число больше нуля, значит повторяем действия

; Печатаем число, доставая цифры из стека, конвертируя их в ASCII символы и выводя в консоль  
printInteger:  
    POP     AX              ; Достаём очередную цифру из стека
    ADD     AL, '0'         ; Конвертируем её в ASCII символ, добавляя '0'
  
    CALL    WriteChar       ; Вызываем процедуру вывода одного символа
    LOOP    printInteger    ; Повторяем действия в цикле до того момента, 
                            ;       пока не распечатаем все цифры числа (т.е. пока число в CX не станет равно 0),   
                            
    ; Восстановление значений в регистрах AX, BX, CX и DX, которые были в них до вывода числа                            
    POP     DX              
    POP     CX  
    POP     BX  
    POP     AX 
    RET                     ; Возвращаемся из процедуры
WriteInteger ENDP           
           
                
; Процедура вывода одного символа, записанного в AL                
WriteChar PROC          
    ; Cохраняем содержимое регистров AX и DX, которые используются в этой процедуре, в стек
    PUSH    AX          
    PUSH    DX  
    
    MOV     DL, AL      ; Помещаем символ, который нужно вывести, в регистр DL
    MOV     AH, 02H     ; Помещаем номер системной функции DOS 02H (вывод символа на дисплей) в регистр AH 
    INT     21h         ; Вызываем функцию
                        
    ; Восстановление значений в регистрах AX и DX, которые были в них до вывода символа                        
    POP     DX          
    POP     AX  
    
    RET                 ; Возвращаемся из процедуры
WriteChar ENDP
                     

; Вывод пробела 
WriteSpace PROC
    MOV     AH, 09H         ; Помещаем номер системной функции DOS 09H (печать строки в консоль) в AH
    LEA     DX, Space       ; Помещаем строку с пробелом в DX
    INT     21H             ; Вызываем функцию
    
    RET 
WriteSpace ENDP              
      

; Переход на новую строку 
NewLine PROC
    MOV     AH, 09H         ; Помещаем номер системной функции DOS 09H (печать строки в консоль) в AH
    LEA     DX, CRLF       ; Помещаем строку с переводом строки в DX
    INT     21H             ; Вызываем функцию
    
    RET 
NewLine ENDP                    
                     
                     
.DATA
    isNegative              DW ?            ; Отрицательность вводимого числа
    arrSize                 DW ?            ; Фактическая длина массива 
    arrWithNumbers          DW 100 DUP(?)   ; Массив

    enterArrSizeMessage     DB 'Введите размер массива:', 0DH, 0AH, 2DH, 2DH, 3EH, 20H, '$'
    enterNumberMessage      DB 'Введите число:', 0DH, 0AH, 2DH, 2DH, 3EH, 20H, '$'
    
    enteredArrMessage       DB 'Введенный массив: $'  
    
    trueMessage             DB 'Да, все числа в массиве имеют одинаковый знак$'						; Сообщение для вывода в случае положительного результата
    falseMessage            DB 'Нет, по крайней мере два числа в массиве имеют различные знаки$'	; Сообщение для вывода в случае отрицательного результата
    
    CRLF                    DB 0DH, 0AH, '$'    ; Перевод строки
    Space                   DB 20H, '$'         ; Пробел для вывода массива чисел в строку                                           